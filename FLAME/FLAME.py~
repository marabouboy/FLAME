#!/usr/bin/python3
#Import Packages:
import re #time, sys, os, re
import argparse
import pysam
import FLAME_FUNC.FLAME_FUNC as FF #Break this down into each part based on the command.

#Input command:
parser = argparse.ArgumentParser(description = "FLAME: Full Length Adjecency Matrix Enumeration") #CREATE A DEFAULT?!
parser.add_argument("-I", dest = "INPUT", help = "Input file")
parser.add_argument("-R", dest = "REF", help = "Reference File in Fasta format") #INSERT A DEFAULT=0 THAT CAUSE DOWNSTREAM FUNCTION TO REMOVED IF IT IS == 0 BUT WILL CONTINUE IF ARGUMENT != 0
parser.add_argument("--range", dest = "RANGE", help = "Variance Range", default = 20)
parser.add_argument("-GTF", dest = "GTF", help = "Reference File in GTF format")
parser.add_argument("-G", dest = "GENE", help = "Targeted Gene")
parser.add_argument("-B", dest = "SAM", help = "Shortread Sequence") #INSERT A DEFAULT=0 THAT CAUSE DOWNSTREAM FUNCTION TO REMOVED IF IT IS == 0 BUT WILL CONTINUE IF ARGUMENT != 0
parser.add_argument("-O", dest = "OUTPUT1", help = "Output Prefix", default = "flame")
#parser.add_argument("-O2", dest = "OUTPUT2", help = "Faulty Output file")
args = parser.parse_args()
print("\n-------------------------------------------------------------------------------------------")
print("\n-----------\tFLAME: Full Length Adjecency Matrix Enumeration\t\t\t-----------\n")

print("-------------------------------------------------------------------------------------------")
print("\n-----------\tInitiating FLAME\t\t\t\t\t\t-----------")
print("Input:\t\t{}\n\
Shortread:\t{}\n\
Reference:\t{}\n\
GTF:\t\t{}\n\
Gene:\t\t{}\n\
Range:\t\t{}\n\
Output:\t\t{}-Suffix\n".format(
    args.INPUT,
    args.SAM,
    args.REF,
    args.GTF,
    args.GENE,
    args.RANGE,
    args.OUTPUT1
))
print("-------------------------------------------------------------------------------------------\n")

#Variables:
##Input Files and References:
INPUT1 = open(args.INPUT, "r")
INPUT2 = open(args.INPUT, "r")
REFFILE = open(args.REF, "r")
REF = ""
GTFFILE = open(args.GTF, "r")
RANGESIZE = int(args.RANGE)
GENENAME = args.GENE

#if args.SAM != None:
#SHORTREAD = pysam.AlignmentFile("%s" %args.SAM, "rb")

NSTDLIST = [] #CHANGE NAME, Storage of the reference as a nested List.
WINDOWSIZE = 2 #FIX SO THAT THIS WINDOWSIZE IS FLEXIBLE

##FLAME: Printing Files:
Counter1 = 0
Counter2 = 0
Counter3 = 0
Counter4 = 0

#Preapre the Fasta reference:
for REFLINE in REFFILE:
    if ">" in REFLINE:
        pass
    else:
        REF += REFLINE.rstrip()

#Prepare GTF reference:
Flame_SPLICECANDIDATES = []

print("-----------\tInitiate Creation of Reference\t\t\t\t\t-----------")
NSTDLIST = FF.CREATEREFFUNC(GTFFILE,
                            args.GENE) #(GTF Filter, Empty List)

print("-----------\tInitiate Filter Function\t\t\t\t\t-----------")
CORRECREADS, FAULTYREADS = FF.FILTERFUNC(INPUT1,
                                         INPUT2,
                                         NSTDLIST,
                                         RANGESIZE) #Input, Reference, Rangesize, CorrectOutput, 

##Print out Correct:
if CORRECREADS != []:
    OUTPUT = open("%s.Correct.bed" %args.OUTPUT1, "w+")
    for i in CORRECREADS:
        OUTPUT.write(str(i) + "\n")
    OUTPUT.close()
else:
    pass

##Print out Faulty:
if FAULTYREADS != []:
    OUTPUT = open("%s.Faulty.bed" %args.OUTPUT1, "w+")
    for i in FAULTYREADS:
        OUTPUT.write(str(i) + "\n")
    OUTPUT.close()
else:
    pass   


TRANSLATECORREC, TRANSLATEFAULTY = FF.TRANSLATEFUNC(NSTDLIST,
                                                    RANGESIZE,
                                                    CORRECREADS,
                                                    FAULTYREADS)
##Print out Correct:
if TRANSLATECORREC != []:
    OUTPUT = open("%s.CorrectTrans.txt" %args.OUTPUT1, "w+")
    for i in TRANSLATECORREC:
        OUTPUT.write(str(i) + "\n")
    OUTPUT.close
else:
    pass

##Print out Faulty:
if TRANSLATEFAULTY != []:
    OUTPUT = open("%s.FaultyTrans.txt" %args.OUTPUT1, "w+")
    for i in TRANSLATEFAULTY:
        OUTPUT.write(str(i) + "\n")
    OUTPUT.close
else:
    pass

print("-----------\tInitiate Creation of Empty Adjecency Matrix\t\t\t-----------")
ADJMTX1 = FF.EMPTYADJMTXFUNC(NSTDLIST)
print("-----------\tInitiate Creation of Adjecency Matrix, Correct\t\t\t-----------")
ADJMTX1 = FF.CORRECTADJMTXFUNC(TRANSLATECORREC,
                               NSTDLIST,
                               ADJMTX1)
##Print out Adjecency Matrix, Correct:
###Print the Column- and Rowheaders.
OUTPUT = open("%s.AdjecencyCorrect.tsv" %args.OUTPUT1, "w+")
for i in ADJMTX1:
    if Counter1 <= (len(NSTDLIST)-1):
        #print(Counter6)
        OUTPUT.write("\t" + str(NSTDLIST[Counter1][0]))
        Counter1 += 1
    elif Counter1 > (len(NSTDLIST)-1):
        OUTPUT.write("\t" + "END" + "\t")
OUTPUT.write("\n")
###Filling the Adjecency Matrix itself.
for i in ADJMTX1:
    if Counter2 <= (len(NSTDLIST)-1):
        OUTPUT.write(str(NSTDLIST[Counter2][0]) + "\t")
        for j in i:
            OUTPUT.write(str(j) + "\t")
        OUTPUT.write("\n")
        Counter2 += 1
    elif Counter2 > (len(NSTDLIST)-1):
        pass
OUTPUT.close()

print("-----------\tInitiate Singling of Faulty Exons\t\t\t\t-----------")
POTNEWEXON = FF.FAULTYSEPERATORFUNC(TRANSLATEFAULTY,
                                    NSTDLIST)
##Print out the raw potential ranges:
OUTPUT = open("%s.RawRanges.txt" %args.OUTPUT1, "w+")
for i in POTNEWEXON:
    OUTPUT.write(str(i) + "\n")
OUTPUT.close()

#for i in NSTDLIST:
#    print(i)
    
print("-----------\tInitiate Novel Splice Site Detection, Part1: Frequency\t\t-----------")
GENEREFERENCE = FF.FREQUENCYSITEFUNC(POTNEWEXON,
                                     NSTDLIST,
                                     RANGESIZE,
                                     WINDOWSIZE)


print("-----------\tInitiate Novel Splice Site Detection, Part2: Threshold\t\t-----------")
Flame_SPLICECANDIDATES = FF.FREQUENCYTHRESHFUNC(GENEREFERENCE,
                                                0.01,
                                                FAULTYREADS)

print("-----------\tInitiate Novel Splice Site Detection, Part3: Splice Signal\t-----------")
Flame_SPLICECANDIDATES = FF.SPLICESIGNALFUNC(Flame_SPLICECANDIDATES,
                                             REF)
##Print out Potential Splice Sites:
OUTPUT = open("%s.PotentialSplice.tsv" %args.OUTPUT1, "w+")
OUTPUT.write("Gene Position" +
             "\t" +
             "Supporting Faulty Reads, Absolute" +
             "\t" +
             "Supporting Faulty Reads, Percent" +
             "\t" +
             "Adjecent Splice Signal" +
#             "\t" +
#             "Short Read Support" +
#             "\t" +
#             "Number of Supporting Short Reads" +
             "\n")
for i in Flame_SPLICECANDIDATES:
    OUTPUT.write(str(i[0]) +
                 "\t" +
                 str(i[1]) +
                 "\t" +
                 str(i[2]) +
                 "\t" +
                 str(i[3]) +
#                 "\t" +
#                 str(i[4]) +
#                 "\t" +
#                 str(i[5]) +
                 "\n")
OUTPUT.close


'''
print("-----------\tInitiate Novel Splice Site Detection, Part4: Shortread\t\t-----------")
Flame_SPLICECANDIDATES = FF.SHORTREADFUNC(SHORTREAD,
                                          Flame_SPLICECANDIDATES,
                                          NSTDLIST,
                                          STARTPOSITION)
'''

print("-----------\tInitiate Quantification of each Splice Permutaiton, Correct\t-----------")
QUANTIFY = FF.QUANTIFYFUNC(TRANSLATECORREC)
print("-----------\tInitiate Quantification of each Splice Permutaiton, Faulty\t-----------")
FQUANTIFY = FF.QUANTIFYFUNC(TRANSLATEFAULTY)
##Print out quantification:
#print(QUANTIFY)
if QUANTIFY != {}:
    OUTPUT = open("%s.QuantificationCorrect.txt" %args.OUTPUT1, "w+")
    for k, v in QUANTIFY.items():
        OUTPUT.write(str(v) +
                     "\t" +
                     str(k) +
                     "\n")
    OUTPUT.close()
else:
    pass

##Print out FAULTYquantification:
if FQUANTIFY != {}:
    OUTPUT = open("%s.QuantificationFaulty.txt" %args.OUTPUT1, "w+") #Change Name of the Output file. ",Faulty"?
    for k, v in FQUANTIFY.items():
        OUTPUT.write(str(v) +
                     "\t" +
                     str(k) +
                     "\n")
    OUTPUT.close()
else:
    pass

print("-----------\tInitiate Creation of Empty Adjecency Matrix\t\t\t-----------")
ADJMTX2 = FF.EMPTYADJMTXFUNC(Flame_SPLICECANDIDATES)
print("-----------\tInitiate Creation of Adjecency Matrix, Faulty\t\t\t-----------")
Flame_ADJMTX2 = FF.FAULTYADJMTXFUNC(POTNEWEXON,
                                    Flame_SPLICECANDIDATES,
                                    ADJMTX2,
                                    RANGESIZE)
##Print out Adjecency Matrix, Faulty:
###Print the Column- and Rowheaders.
OUTPUT = open("%s.AdjecencyFaulty.tsv" %args.OUTPUT1, "w+")
for i in ADJMTX2:
    if Counter3 <= (len(Flame_SPLICECANDIDATES)-1):
        #print(Counter6)
        OUTPUT.write("\t" + str(Flame_SPLICECANDIDATES[Counter3][0]))
        Counter3 += 1
    elif Counter3 > (len(Flame_SPLICECANDIDATES)-1):
        OUTPUT.write("\t" + "END" + "\t")
OUTPUT.write("\n")
###Filling the Adjecency Matrix itself.
for i in ADJMTX2:
    if Counter4 <= (len(Flame_SPLICECANDIDATES)-1):
        OUTPUT.write(str(Flame_SPLICECANDIDATES[Counter4][0]) + "\t")
        for j in i:
            OUTPUT.write(str(j) + "\t")
        OUTPUT.write("\n")
        Counter4 += 1
    elif Counter4 > (len(Flame_SPLICECANDIDATES)-1):
        pass
OUTPUT.close()
        

